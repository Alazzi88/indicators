// This source code is subject to the terms of the Mozilla Public License 4.0 at https://mozilla.org/MPL/2.0/
// Â© LonesomeTheBlue

//@version=5
indicator('3zzo.com-Options-Indicator1', overlay=true)
prd = input.int(defval=10, title='Pivot Period', minval=4, maxval=30, group='Setup')
ppsrc = input.string(defval='High/Low', title='Source', options=['High/Low', 'Close/Open'], group='Setup')
maxnumpp = input.int(defval=20, title=' Maximum Number of Pivot', minval=5, maxval=100, group='Setup')
ChannelW = input.int(defval=10, title='Maximum Channel Width %', minval=1, group='Setup')
maxnumsr = input.int(defval=5, title=' Maximum Number of S/R', minval=1, maxval=10, group='Setup')
min_strength = input.int(defval=2, title=' Minimum Strength', minval=1, maxval=10, group='Setup')
labelloc = input.int(defval=20, title='Label Location', group='Colors', tooltip='Positive numbers reference future bars, negative numbers reference histical bars')
linestyle = input.string(defval='Dotted', title='Line Style', options=['Solid', 'Dotted', 'Dashed'], group='Colors')
linewidth = input.int(defval=1, title='Line Width', minval=1, maxval=4, group='Colors')
resistancecolor = input.color(defval=color.orange, title='Resistance Color', group='Colors')
supportcolor = input.color(defval=color.yellow, title='Support Color', group='Colors')
showpp = input(false, title='Show Point Points')

float src11 = ppsrc == 'High/Low' ? high : math.max(close, open)
float src22 = ppsrc == 'High/Low' ? low : math.min(close, open)
float ph = ta.pivothigh(src11, prd, prd)
float pl = ta.pivotlow(src22, prd, prd)

plotshape(ph and showpp, text='H', style=shape.labeldown, color=na, textcolor=color.new(color.orange, 0), location=location.abovebar, offset=-prd)
plotshape(pl and showpp, text='L', style=shape.labelup, color=na, textcolor=color.new(color.yellow, 0), location=location.belowbar, offset=-prd)

Lstyle = linestyle == 'Dashed' ? line.style_dashed : linestyle == 'small' ? line.style_solid : line.style_dotted

//calculate maximum S/R channel zone width
prdhighest = ta.highest(300)
prdlowest = ta.lowest(300)
cwidth = (prdhighest - prdlowest) * ChannelW / 100

var pivotvals = array.new_float(0)

if ph or pl
    array.unshift(pivotvals, ph ? ph : pl)
    if array.size(pivotvals) > maxnumpp  // limit the array size
        array.pop(pivotvals)

get_sr_vals(ind) =>
    float lo = array.get(pivotvals, ind)
    float hi = lo
    int numpp = 0
    for y = 0 to array.size(pivotvals) - 1 by 1
        float cpp = array.get(pivotvals, y)
        float wdth = cpp <= lo ? hi - cpp : cpp - lo
        if wdth <= cwidth  // fits the max channel width?
            if cpp <= hi
                lo := math.min(lo, cpp)
            else
                hi := math.max(hi, cpp)

            numpp += 1
            numpp
    [hi, lo, numpp]

var sr_up_level = array.new_float(0)
var sr_dn_level = array.new_float(0)
sr_strength = array.new_float(0)

find_loc(strength) =>
    ret = array.size(sr_strength)
    for i = ret > 0 ? array.size(sr_strength) - 1 : na to 0 by 1
        if strength <= array.get(sr_strength, i)
            break
        ret := i
        ret
    ret

check_sr(hi, lo, strength) =>
    ret = true
    for i = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        //included?
        if array.get(sr_up_level, i) >= lo and array.get(sr_up_level, i) <= hi or array.get(sr_dn_level, i) >= lo and array.get(sr_dn_level, i) <= hi
            if strength >= array.get(sr_strength, i)
                array.remove(sr_strength, i)
                array.remove(sr_up_level, i)
                array.remove(sr_dn_level, i)
                ret
            else
                ret := false
                ret
            break
    ret

var sr_lines = array.new_line(11, na)
var sr_labels = array.new_label(11, na)

for x = 1 to 10 by 1
    rate = 100 * (label.get_y(array.get(sr_labels, x)) - close) / close
    label.set_text(array.get(sr_labels, x), text=str.tostring(label.get_y(array.get(sr_labels, x))))
    label.set_x(array.get(sr_labels, x), x=bar_index + labelloc)
    label.set_color(array.get(sr_labels, x), color=label.get_y(array.get(sr_labels, x)) >= close ? color.orange : color.yellow)
    label.set_textcolor(array.get(sr_labels, x), textcolor=label.get_y(array.get(sr_labels, x)) >= close ? color.white : color.black)
    label.set_style(array.get(sr_labels, x), style=label.get_y(array.get(sr_labels, x)) >= close ? label.style_label_down : label.style_label_up)
    line.set_color(array.get(sr_lines, x), color=line.get_y1(array.get(sr_lines, x)) >= close ? resistancecolor : supportcolor)

if ph or pl
    //because of new calculation, remove old S/R levels
    array.clear(sr_up_level)
    array.clear(sr_dn_level)
    array.clear(sr_strength)
    //find S/R zones
    for x = 0 to array.size(pivotvals) - 1 by 1
        [hi, lo, strength] = get_sr_vals(x)
        if check_sr(hi, lo, strength)
            loc = find_loc(strength)
            // if strength is in first maxnumsr sr then insert it to the arrays 
            if loc < maxnumsr and strength >= min_strength
                array.insert(sr_strength, loc, strength)
                array.insert(sr_up_level, loc, hi)
                array.insert(sr_dn_level, loc, lo)
                // keep size of the arrays = 5
                if array.size(sr_strength) > maxnumsr
                    array.pop(sr_strength)
                    array.pop(sr_up_level)
                    array.pop(sr_dn_level)

    for x = 1 to 10 by 1
        line.delete(array.get(sr_lines, x))
        label.delete(array.get(sr_labels, x))

    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        rate = 100 * (mid - close) / close
        array.set(sr_labels, x + 1, label.new(x=bar_index + labelloc, y=mid, text=str.tostring(mid), color=mid >= close ? color.red : color.lime, textcolor=mid >= close ? color.white : color.black, style=mid >= close ? label.style_label_down : label.style_label_up))

        array.set(sr_lines, x + 1, line.new(x1=bar_index, y1=mid, x2=bar_index - 1, y2=mid, extend=extend.both, color=mid >= close ? resistancecolor : supportcolor, style=Lstyle, width=linewidth))

f_crossed_over() =>
    ret = false
    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        if close[1] <= mid and close > mid
            ret := true
            ret
    ret

f_crossed_under() =>
    ret = false
    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        if close[1] >= mid and close < mid
            ret := true
            ret
    ret

alertcondition(f_crossed_over(), title='Resistance Broken', message='Resistance Broken')
alertcondition(f_crossed_under(), title='Support Broken', message='Support Broken')




// 
//-----------------------------------------------------------------------------{
//SMC
//-----------------------------------------------------------------------------{
// 
//-----------------------------------------------------------------------------{
//Constants
//-----------------------------------------------------------------------------{
color TRANSP_CSS = #ffffff00

//Tooltips
string MODE_TOOLTIP          = 'Allows to display historical Structure or only the recent ones'
string STYLE_TOOLTIP         = 'Indicator color theme'
string COLOR_CANDLES_TOOLTIP = 'Display additional candles with a color reflecting the current trend detected by structure'
string SHOW_INTERNAL         = 'Display internal market structure'
string CONFLUENCE_FILTER     = 'Filter non significant internal structure breakouts'
string SHOW_SWING            = 'Display swing market Structure'
string SHOW_SWING_POINTS     = 'Display swing point as labels on the chart'
string SHOW_SWHL_POINTS      = 'Highlight most recent strong and weak high/low points on the chart'
string INTERNAL_OB           = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
string SWING_OB              = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
string FILTER_OB             = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
string SHOW_EQHL             = 'Display equal highs and equal lows on the chart'
string EQHL_BARS             = 'Number of bars used to confirm equal highs and equal lows'
string EQHL_THRESHOLD        = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
string SHOW_FVG              = 'Display fair values gaps on the chart'
string AUTO_FVG              = 'Filter out non significant fair value gaps'
string FVG_TF                = 'Fair value gaps timeframe'
string EXTEND_FVG            = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
string PED_ZONES             = 'Display premium, discount, and equilibrium zones on chart'

//-----------------------------------------------------------------------------{
//Settings
//-----------------------------------------------------------------------------{
//General
//----------------------------------------{
mode = input.string('Historical'
  , options = ['Historical', 'Present']
  , group = 'Smart Money Concepts'
  , tooltip = MODE_TOOLTIP)

style = input.string('Colored'
  , options = ['Colored', 'Monochrome']
  , group = 'Smart Money Concepts'
  , tooltip = STYLE_TOOLTIP)

show_trend = input(false, 'Color Candles'
  , group = 'Smart Money Concepts'
  , tooltip = COLOR_CANDLES_TOOLTIP)

//----------------------------------------}
//Internal Structure
//----------------------------------------{
show_internals = input(true, 'Show Internal Structure'
  , group = 'Real Time Internal Structure'
  , tooltip = SHOW_INTERNAL)

show_ibull = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

swing_ibull_css = input(#089981, ''
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

//Bear Structure
show_ibear = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

swing_ibear_css = input(#f23645, ''
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

ifilter_confluence = input(false, 'Confluence Filter'
  , group = 'Real Time Internal Structure'
  , tooltip = CONFLUENCE_FILTER)

internal_structure_size = input.string('Tiny', 'Internal Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Internal Structure')

//----------------------------------------}
//Swing Structure
//----------------------------------------{
show_Structure = input(true, 'Show Swing Structure'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING)

//Bull Structure
show_bull = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

swing_bull_css = input(#089981, ''
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

//Bear Structure
show_bear = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

swing_bear_css = input(#f23645, ''
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

swing_structure_size = input.string('Small', 'Swing Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Swing Structure')

//Swings
show_swings = input(false, 'Show Swings Points'
  , inline = 'swings'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING_POINTS)

length = input.int(50, ''
  , minval = 10
  , inline = 'swings'
  , group = 'Real Time Swing Structure')

show_hl_swings = input(true, 'Show Strong/Weak High/Low'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWHL_POINTS)

//----------------------------------------}
//Order Blocks
//----------------------------------------{
show_iob = input(true, 'Internal Order Blocks'
  , inline = 'iob'
  , group = 'Order Blocks'
  , tooltip = INTERNAL_OB)

iob_showlast = input.int(5, ''
  , minval = 1
  , inline = 'iob'
  , group = 'Order Blocks')

show_ob = input(false, 'Swing Order Blocks'
  , inline = 'ob'
  , group = 'Order Blocks'
  , tooltip = SWING_OB)

ob_showlast = input.int(5, ''
  , minval = 1
  , inline = 'ob'
  , group = 'Order Blocks')

ob_filter = input.string('Atr', 'Order Block Filter'
  , options = ['Atr', 'Cumulative Mean Range']
  , group = 'Order Blocks'
  , tooltip = FILTER_OB)

ibull_ob_css = input.color(#0770153f,  'Internal Bullish OB'
  , group = 'Order Blocks')

ibear_ob_css = input.color(#b824293a, 'Internal Bearish OB'
  , group = 'Order Blocks')

bull_ob_css = input.color(color.new(#0770153f, 80), 'Bullish OB'
  , group = 'Order Blocks')

bear_ob_css = input.color(color.new(#b824293a, 80), 'Bearish OB'
  , group = 'Order Blocks')

//----------------------------------------}
//EQH/EQL
//----------------------------------------{
show_eq = input(true, 'Equal High/Low'
  , group = 'EQH/EQL'
  , tooltip = SHOW_EQHL)

eq_len = input.int(3, 'Bars Confirmation'
  , minval = 1
  , group = 'EQH/EQL'
  , tooltip = EQHL_BARS)

eq_threshold = input.float(0.1, 'Threshold'
  , minval = 0
  , maxval = 0.5
  , step = 0.1
  , group = 'EQH/EQL'
  , tooltip = EQHL_THRESHOLD)

eq_size = input.string('Tiny', 'Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'EQH/EQL')

//----------------------------------------}
//Fair Value Gaps
//----------------------------------------{
show_fvg = input(true, 'Fair Value Gaps'
  , group = 'Fair Value Gaps'
  , tooltip = SHOW_FVG)
  
fvg_auto = input(false, "Auto Threshold"
  , group = 'Fair Value Gaps'
  , tooltip = AUTO_FVG)

fvg_tf = input.timeframe('', "Timeframe"
  , group = 'Fair Value Gaps'
  , tooltip = FVG_TF)

bull_fvg_css = input.color(color.new(#00ff68, 70), 'Bullish FVG'
  , group = 'Fair Value Gaps')

bear_fvg_css = input.color(color.new(#ff0008, 70), 'Bearish FVG'
  , group = 'Fair Value Gaps')

fvg_extend = input.int(1, "Extend FVG"
  , minval = 0
  , group = 'Fair Value Gaps'
  , tooltip = EXTEND_FVG)

//----------------------------------------}
//Previous day/week high/low
//----------------------------------------{
//Daily
show_pdhl = input(true, 'Daily'
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

pdhl_style = input.string('â¯â¯â¯', ''
  , options = ['â¯â¯â¯', '----', 'Â·Â·Â·Â·']
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

pdhl_css = input(#2157f3, ''
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

//Weekly
show_pwhl = input(false, 'Weekly'
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

pwhl_style = input.string('â¯â¯â¯', ''
  , options = ['â¯â¯â¯', '----', 'Â·Â·Â·Â·']
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

pwhl_css = input(#2157f3, ''
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

//Monthly
show_pmhl = input(false, 'Monthly'
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

pmhl_style = input.string('â¯â¯â¯', ''
  , options = ['â¯â¯â¯', '----', 'Â·Â·Â·Â·']
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

pmhl_css = input(#2157f3, ''
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

//----------------------------------------}
//Premium/Discount zones
//----------------------------------------{
show_sd = input(true, 'ÙÙØ·ÙØ© ØªØµØ±ÙÙ'
  , group = 'ÙÙØ·ÙØ© ØªØµØ±ÙÙ ' 
  , tooltip = PED_ZONES)

premium_css = input.color(#f23645, 'Premium Zone'
  , group = 'Premium & Discount Zones')

eq_css = input.color(#b2b5be, ''
  , group = 'Premium & Discount Zones')

discount_css = input.color(#089981, 'Ø§ÙÙÙØ·ÙØ© Ø§ÙØ°ÙØ¨ÙØ© ÙÙØ´Ø±Ø§Ø¡'
  , group = 'ÙÙØ·ÙØ© Ø´Ø±Ø§Ø¡')

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
n = bar_index

atr = ta.atr(200)
cmean_range = ta.cum(high - low) / n

//HL Output function
hl() => [high, low]

//Get ohlc values function
get_ohlc()=> [close[1], open[1], high, low, high[2], low[2]]

//Display Structure function
display_Structure(x, y, txt, css, dashed, down, lbl_size)=>
    structure_line = line.new(x, y, n, y
      , color = css
      , style = dashed ? line.style_dashed : line.style_solid)

    structure_lbl = label.new(int(math.avg(x, n)), y, txt
      , color = TRANSP_CSS
      , textcolor = css
      , style = down ? label.style_label_down : label.style_label_up
      , size = lbl_size)

    if mode == 'Present'
        line.delete(structure_line[1])
        label.delete(structure_lbl[1])

//Swings detection/measurements
swings(len)=>
    var os = 0
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : 0
    btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]

//Order block coordinates function
ob_coord(use_max, loc, target_top, target_btm, target_left, target_type)=>
    min = 99999999.
    max = 0.
    idx = 1

    ob_threshold = ob_filter == 'Atr' ? atr : cmean_range 

    //Search for highest/lowest high within the structure interval and get range
    if use_max
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                max := math.max(high[i], max)
                min := max == high[i] ? low[i] : min
                idx := max == high[i] ? i : idx
    else
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                min := math.min(low[i], min)
                max := min == low[i] ? high[i] : max
                idx := min == low[i] ? i : idx

    array.unshift(target_top, max)
    array.unshift(target_btm, min)
    array.unshift(target_left, time[idx])
    array.unshift(target_type, use_max ? -1 : 1)

//Set order blocks
display_ob(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    for i = 0 to math.min(show_last-1, size-1)
        get_box = array.get(boxes, i)

        box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
        box.set_rightbottom(get_box, array.get(target_left, i), array.get(target_btm, i))
        box.set_extend(get_box, extend.right)

        color css = na
        
        if swing 
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
                border_css = array.get(target_type, i) == 1 ? #b2b5be : #5d606b
                box.set_border_color(get_box, border_css)
            else
                css := array.get(target_type, i) == 1 ? bull_ob_css : bear_ob_css
                box.set_border_color(get_box, css)

            box.set_bgcolor(get_box, css)
        else
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
            else
                css := array.get(target_type, i) == 1 ? ibull_ob_css : ibear_ob_css
            
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
        
//Line Style function
get_line_style(style) =>
    out = switch style
        'â¯â¯â¯'  => line.style_solid
        '----' => line.style_dashed
        'Â·Â·Â·Â·' => line.style_dotted

//Set line/labels function for previous high/lows
phl(h, l, tf, css)=>
    var line high_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label high_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}H', tf)
      , color = TRANSP_CSS
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    var line low_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label low_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}L', tf)
      , color = TRANSP_CSS
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    hy = ta.valuewhen(h != h[1], h, 1)
    hx = ta.valuewhen(h == high, time, 1)

    ly = ta.valuewhen(l != l[1], l, 1)
    lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        ext = time + (time - time[1])*20

        //High
        line.set_xy1(high_line, hx, hy)
        line.set_xy2(high_line, ext, hy)

        label.set_xy(high_lbl, ext, hy)

        //Low
        line.set_xy1(low_line, lx, ly)
        line.set_xy2(low_line, ext, ly)

        label.set_xy(low_lbl, ext, ly)

//-----------------------------------------------------------------------------}
//Global variables
//-----------------------------------------------------------------------------{
var trend = 0, var itrend = 0

var top_y = 0., var top_x = 0
var btm_y = 0., var btm_x = 0

var itop_y = 0., var itop_x = 0
var ibtm_y = 0., var ibtm_x = 0

var trail_up = high, var trail_dn = low
var trail_up_x = 0,  var trail_dn_x = 0

var top_cross = true,  var btm_cross = true
var itop_cross = true, var ibtm_cross = true

var txt_top = '',  var txt_btm = ''

//Alerts
bull_choch_alert = false 
bull_bos_alert   = false 

bear_choch_alert = false 
bear_bos_alert   = false 

bull_ichoch_alert = false 
bull_ibos_alert   = false 

bear_ichoch_alert = false 
bear_ibos_alert   = false 

bull_iob_break = false 
bear_iob_break = false

bull_ob_break = false 
bear_ob_break = false

eqh_alert = false 
eql_alert = false 

//Structure colors
var bull_css = style == 'Monochrome' ? #b2b5be 
  : swing_bull_css

var bear_css = style == 'Monochrome' ? #b2b5be 
  : swing_bear_css

var ibull_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibull_css

var ibear_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibear_css

//Labels size
var internal_structure_lbl_size = internal_structure_size == 'Tiny' 
  ? size.tiny 
  : internal_structure_size == 'Small' 
  ? size.small 
  : size.normal 

var swing_structure_lbl_size = swing_structure_size == 'Tiny' 
  ? size.tiny 
  : swing_structure_size == 'Small' 
  ? size.small 
  : size.normal 

var eqhl_lbl_size = eq_size == 'Tiny' 
  ? size.tiny 
  : eq_size == 'Small' 
  ? size.small
  : size.normal 

//Swings
[top, btm] = swings(length)

[itop, ibtm] = swings(5)

//-----------------------------------------------------------------------------}
//Pivot High
//-----------------------------------------------------------------------------{
var line extend_top = na

var label extend_top_lbl = label.new(na, na
  , color = TRANSP_CSS
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.tiny)

if top
    top_cross := true
    txt_top := top > top_y ? 'HH' : 'LH'

    if show_swings
        top_lbl = label.new(n-length, top, txt_top
          , color = TRANSP_CSS
          , textcolor = bear_css
          , style = label.style_label_down
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(top_lbl[1])

    //Extend recent top to last bar
    line.delete(extend_top[1])
    extend_top := line.new(n-length, top, n, top
      , color = bear_css)

    top_y := top
    top_x := n - length

    trail_up := top
    trail_up_x := n - length

if itop
    itop_cross := true

    itop_y := itop
    itop_x := n - 5

//Trailing maximum
trail_up := math.max(high, trail_up)
trail_up_x := trail_up == high ? n : trail_up_x

//Set top extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_top, trail_up_x, trail_up)
    line.set_xy2(extend_top, n + 20, trail_up)

    label.set_x(extend_top_lbl, n + 20)
    label.set_y(extend_top_lbl, trail_up)
    label.set_text(extend_top_lbl, trend < 0 ? 'Ø§Ø±ØªØ¯Ø§Ø¯ ÙØ§Ø¨Ø·' : '')

//-----------------------------------------------------------------------------}
//Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSP_CSS
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.tiny)

if btm
    btm_cross := true
    txt_btm := btm < btm_y ? 'LL' : 'HL'
    
    if show_swings
        btm_lbl = label.new(n - length, btm, txt_btm
          , color = TRANSP_CSS
          , textcolor = bull_css
          , style = label.style_label_up
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    //Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(n - length, btm, n, btm
      , color = bull_css)

    btm_y := btm
    btm_x := n-length

    trail_dn := btm
    trail_dn_x := n-length

if ibtm
    ibtm_cross := true

    ibtm_y := ibtm
    ibtm_x := n - 5

//Trailing minimum
trail_dn := math.min(low, trail_dn)
trail_dn_x := trail_dn == low ? n : trail_dn_x

//Set btm extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_btm, trail_dn_x, trail_dn)
    line.set_xy2(extend_btm, n + 20, trail_dn)

    label.set_x(extend_btm_lbl, n + 20)
    label.set_y(extend_btm_lbl, trail_dn)
    label.set_text(extend_btm_lbl, trend > 0 ? 'Ø§Ø±ØªØ¯Ø§Ø¯ ØµØ¹ÙØ¯' : '')

//-----------------------------------------------------------------------------}
//Order Blocks Arrays
//-----------------------------------------------------------------------------{
var iob_top = array.new_float(0)
var iob_btm = array.new_float(0)
var iob_left = array.new_int(0)
var iob_type = array.new_int(0)

var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)

//-----------------------------------------------------------------------------}
//Pivot High BOS/CHoCH
//-----------------------------------------------------------------------------{
//Filtering
var bull_concordant = true

if ifilter_confluence
    bull_concordant := high - math.max(close, open) > math.min(close, open - low)

//Detect internal bullish Structure
if ta.crossover(close, itop_y) and itop_cross and top_y != itop_y and bull_concordant
    bool choch = na
    
    if itrend < 0
        choch := true
        bull_ichoch_alert := true
    else 
        bull_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if show_internals
        if show_ibull == 'All' or (show_ibull == 'BOS' and not choch) or (show_ibull == 'CHoCH' and choch)
            display_Structure(itop_x, itop_y, txt, ibull_css, true, true, internal_structure_lbl_size)
    
    itop_cross := false
    itrend := 1
    
    //Internal Order Block
    if show_iob
        ob_coord(false, itop_x, iob_top, iob_btm, iob_left, iob_type)

//Detect bullish Structure
if ta.crossover(close, top_y) and top_cross
    bool choch = na
    
    if trend < 0
        choch := true
        bull_choch_alert := true
    else 
        bull_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if show_Structure
        if show_bull == 'All' or (show_bull == 'BOS' and not choch) or (show_bull == 'CHoCH' and choch)
            display_Structure(top_x, top_y, txt, bull_css, false, true, swing_structure_lbl_size)
    
    //Order Block
    if show_ob
        ob_coord(false, top_x, ob_top, ob_btm, ob_left, ob_type)

    top_cross := false
    trend := 1

//-----------------------------------------------------------------------------}
//Pivot Low BOS/CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if ifilter_confluence
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

//Detect internal bearish Structure
if ta.crossunder(close, ibtm_y) and ibtm_cross and btm_y != ibtm_y and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
        bear_ichoch_alert := true
    else 
        bear_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if show_internals
        if show_ibear == 'All' or (show_ibear == 'BOS' and not choch) or (show_ibear == 'CHoCH' and choch)
            display_Structure(ibtm_x, ibtm_y, txt, ibear_css, true, false, internal_structure_lbl_size)
    
    ibtm_cross := false
    itrend := -1
    
    //Internal Order Block
    if show_iob
        ob_coord(true, ibtm_x, iob_top, iob_btm, iob_left, iob_type)

//Detect bearish Structure
if ta.crossunder(close, btm_y) and btm_cross
    bool choch = na
    
    if trend > 0
        choch := true
        bear_choch_alert := true
    else 
        bear_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if show_Structure
        if show_bear == 'All' or (show_bear == 'BOS' and not choch) or (show_bear == 'CHoCH' and choch)
            display_Structure(btm_x, btm_y, txt, bear_css, false, false, swing_structure_lbl_size)
    
    //Order Block
    if show_ob
        ob_coord(true, btm_x, ob_top, ob_btm, ob_left, ob_type)

    btm_cross := false
    trend := -1

//-----------------------------------------------------------------------------}
//Order Blocks
//-----------------------------------------------------------------------------{
//Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

//Delete internal order blocks box coordinates if top/bottom is broken
for element in iob_type
    index = array.indexof(iob_type, element)

    if close < array.get(iob_btm, index) and element == 1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index) 
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bull_iob_break := true

    else if close > array.get(iob_top, index) and element == -1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index)
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bear_iob_break := true

//Delete internal order blocks box coordinates if top/bottom is broken
for element in ob_type
    index = array.indexof(ob_type, element)

    if close < array.get(ob_btm, index) and element == 1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index) 
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bull_ob_break := true

    else if close > array.get(ob_top, index) and element == -1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index)
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bear_ob_break := true

iob_size = array.size(iob_type)
ob_size = array.size(ob_type)

if barstate.isfirst
    if show_iob
        for i = 0 to iob_showlast-1
            array.push(iob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
    if show_ob
        for i = 0 to ob_showlast-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))

if iob_size > 0
    if barstate.islast
        display_ob(iob_boxes, iob_top, iob_btm, iob_left, iob_type, iob_showlast, false, iob_size)

if ob_size > 0
    if barstate.islast
        display_ob(ob_boxes, ob_top, ob_btm, ob_left, ob_type, ob_showlast, true, ob_size)

//-----------------------------------------------------------------------------}
//EQH/EQL
//-----------------------------------------------------------------------------{
var eq_prev_top = 0.
var eq_top_x = 0

var eq_prev_btm = 0.
var eq_btm_x = 0

if show_eq
    eq_top = ta.pivothigh(eq_len, eq_len)
    eq_btm = ta.pivotlow(eq_len, eq_len)

    if eq_top 
        max = math.max(eq_top, eq_prev_top)
        min = math.min(eq_top, eq_prev_top)
        
        if max < min + atr * eq_threshold
            eqh_line = line.new(eq_top_x, eq_prev_top, n-eq_len, eq_top
              , color = bear_css
              , style = line.style_dotted)

            eqh_lbl = label.new(int(math.avg(n-eq_len, eq_top_x)), eq_top, 'EQH'
              , color = #00000000
              , textcolor = bear_css
              , style = label.style_label_down
              , size = eqhl_lbl_size)

            if mode == 'Present'
                line.delete(eqh_line[1])
                label.delete(eqh_lbl[1])
            
            eqh_alert := true

        eq_prev_top := eq_top
        eq_top_x := n-eq_len

    if eq_btm 
        max = math.max(eq_btm, eq_prev_btm)
        min = math.min(eq_btm, eq_prev_btm)
        
        if min > max - atr * eq_threshold
            eql_line = line.new(eq_btm_x, eq_prev_btm, n-eq_len, eq_btm
              , color = bull_css
              , style = line.style_dotted)

            eql_lbl = label.new(int(math.avg(n-eq_len, eq_btm_x)), eq_btm, 'EQL'
              , color = #00000000
              , textcolor = bull_css
              , style = label.style_label_up
              , size = eqhl_lbl_size)

            eql_alert := true

            if mode == 'Present'
                line.delete(eql_line[1])
                label.delete(eql_lbl[1])

        eq_prev_btm := eq_btm
        eq_btm_x := n-eq_len

//-----------------------------------------------------------------------------}
//Fair Value Gaps
//-----------------------------------------------------------------------------{
var bullish_fvg_max = array.new_box(0)
var bullish_fvg_min = array.new_box(0)

var bearish_fvg_max = array.new_box(0)
var bearish_fvg_min = array.new_box(0)

float bullish_fvg_avg = na
float bearish_fvg_avg = na

bullish_fvg_cnd = false
bearish_fvg_cnd = false

[src_c1, src_o1, src_h, src_l, src_h2, src_l2] =
  request.security(syminfo.tickerid, fvg_tf, get_ohlc())

if show_fvg
    delta_per = (src_c1 - src_o1) / src_o1 * 100

    change_tf = timeframe.change(fvg_tf)

    threshold = fvg_auto ? ta.cum(math.abs(change_tf ? delta_per : 0)) / n * 2 
      : 0

    //FVG conditions
    bullish_fvg_cnd := src_l > src_h2
      and src_c1 > src_h2 
      and delta_per > threshold
      and change_tf

    bearish_fvg_cnd := src_h < src_l2 
      and src_c1 < src_l2 
      and -delta_per > threshold
      and change_tf

    //FVG Areas
    if bullish_fvg_cnd
        array.unshift(bullish_fvg_max, box.new(n-1, src_l, n + fvg_extend, math.avg(src_l, src_h2)
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
        
        array.unshift(bullish_fvg_min, box.new(n-1, math.avg(src_l, src_h2), n + fvg_extend, src_h2
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
    
    if bearish_fvg_cnd
        array.unshift(bearish_fvg_max, box.new(n-1, src_h, n + fvg_extend, math.avg(src_h, src_l2)
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))
        
        array.unshift(bearish_fvg_min, box.new(n-1, math.avg(src_h, src_l2), n + fvg_extend, src_l2
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))

    for bx in bullish_fvg_min
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullish_fvg_max, array.indexof(bullish_fvg_min, bx)))
    
    for bx in bearish_fvg_max
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearish_fvg_min, array.indexof(bearish_fvg_max, bx)))

//-----------------------------------------------------------------------------}
//Previous day/week high/lows
//-----------------------------------------------------------------------------{
//Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, 'D', hl()
  , lookahead = barmerge.lookahead_on)

//Weekly high/low
[pwh, pwl] = request.security(syminfo.tickerid, 'W', hl()
  , lookahead = barmerge.lookahead_on)

//Monthly high/low
[pmh, pml] = request.security(syminfo.tickerid, 'M', hl()
  , lookahead = barmerge.lookahead_on)

//Display Daily
if show_pdhl
    phl(pdh, pdl, 'D', pdhl_css)

//Display Weekly
if show_pwhl
    phl(pwh, pwl, 'W', pwhl_css)
    
//Display Monthly
if show_pmhl
    phl(pmh, pml, 'M', pmhl_css)

//-----------------------------------------------------------------------------}
//Premium/Discount/Equilibrium zones
//-----------------------------------------------------------------------------{
var premium = box.new(na, na, na, na
  , bgcolor = color.new(premium_css, 80)
  , border_color = na)

var premium_lbl = label.new(na, na
  , text = 'Premium'
  , color = TRANSP_CSS
  , textcolor = premium_css
  , style = label.style_label_down
  , size = size.small)

var eq = box.new(na, na, na, na
  , bgcolor = color.rgb(120, 123, 134, 80)
  , border_color = na)

var eq_lbl = label.new(na, na
  , text = 'Equilibrium'
  , color = TRANSP_CSS
  , textcolor = eq_css
  , style = label.style_label_left
  , size = size.small)

var discount = box.new(na, na, na, na
  , bgcolor = color.new(discount_css, 80)
  , border_color = na)

var discount_lbl = label.new(na, na
  , text = 'Discount'
  , color = TRANSP_CSS
  , textcolor = discount_css
  , style = label.style_label_up
  , size = size.small)

//Show Premium/Discount Areas
if barstate.islast and show_sd
    avg = math.avg(trail_up, trail_dn)

    box.set_lefttop(premium, math.max(top_x, btm_x), trail_up)
    box.set_rightbottom(premium, n, .95 * trail_up + .05 * trail_dn)

    label.set_xy(premium_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_up)

    box.set_lefttop(eq, math.max(top_x, btm_x), .525 * trail_up + .475*trail_dn)
    box.set_rightbottom(eq, n, .525 * trail_dn + .475 * trail_up)

    label.set_xy(eq_lbl, n, avg)
    
    box.set_lefttop(discount, math.max(top_x, btm_x), .95 * trail_dn + .05 * trail_up)
    box.set_rightbottom(discount, n, trail_dn)
    label.set_xy(discount_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_dn)

//-----------------------------------------------------------------------------}
//Trend
//-----------------------------------------------------------------------------{
var color trend_css = na

if show_trend
    if style == 'Colored'
        trend_css := itrend == 1 ? bull_css : bear_css
    else if style == 'Monochrome'
        trend_css := itrend == 1 ? #b2b5be : #5d606b

plotcandle(open, high, low, close
  , color = trend_css
  , wickcolor = trend_css
  , bordercolor = trend_css
  , editable = false)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
//Internal Structure
alertcondition(bull_ibos_alert, 'Internal Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_ichoch_alert, 'Internal Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_ibos_alert, 'Internal Bearish BOS', 'Internal Bearish BOS formed')
alertcondition(bear_ichoch_alert, 'Internal Bearish CHoCH', 'Internal Bearish CHoCH formed')

//Swing Structure
alertcondition(bull_bos_alert, 'Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_choch_alert, 'Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_bos_alert, 'Bearish BOS', 'Bearish BOS formed')
alertcondition(bear_choch_alert, 'Bearish CHoCH', 'Bearish CHoCH formed')

//order Blocks
alertcondition(bull_iob_break, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(bear_iob_break, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')

alertcondition(bull_ob_break, 'Bullish Swing OB Breakout', 'Price broke bullish swing OB')
alertcondition(bear_ob_break, 'Bearish Swing OB Breakout', 'Price broke bearish swing OB')

//EQH/EQL
alertcondition(eqh_alert, 'Equal Highs', 'Equal highs detected')
alertcondition(eql_alert, 'Equal Lows', 'Equal lows detected')

//FVG
alertcondition(bullish_fvg_cnd, 'Bullish FVG', 'Bullish FVG formed')
alertcondition(bearish_fvg_cnd, 'Bearish FVG', 'Bearish FVG formed')

//-----------------------------------------------------------------------------}





// // ==========================trend======================== //
src =  input(hl2, title="Source",group = "trendd Continuation Signals with TP & SL")
Multiplier = input.float(4.8,title="Sensitivity (0.5 - 5)", step=1.6, defval=4.8, minval=0.5, maxval=5,group = "trendd Continuation Signals with TP & SL")
atrrPeriods = input.int(17,title="atrr Length", defval=17,group = "trendd Continuation Signals with TP & SL")
atrrCalcMethod= input.string("Method 1",title = "atrr Calculation Methods",options = ["Method 1","Method 2"],group = "trendd Continuation Signals with TP & SL")
cloud_val = input.int(12,title = "Cloud Moving Average Length", defval = 12,minval = 5, maxval = 500,group = "trendd Continuation Signals with TP & SL")
stopLossVal  = input.float(0.2, title="Stop Loss Percent (0 for Disabling)",defval = 0.2, minval=0,group = "trendd Continuation Signals with TP & SL")
showBuySellSignals = input.bool(true,title="Show Buy/Sell Signals", defval=true,group = "trendd Continuation Signals with TP & SL")
showMovingAverageCloud = input.bool(true, title="Show Cloud MA",group = "trendd Continuation Signals with TP & SL")

percent(nom, div) =>
    100 * nom / div

src1 = ta.hma(open, 5)[1] 
src2 = ta.hma(close, 12)
momm1 = ta.change(src1)
momm2 = ta.change(src2)
f1(m, n) => m >= n ? m : 0.0
f2(m, n) => m >= n ? 0.0 : -m
m1 = f1(momm1, momm2)
m2 = f2(momm1, momm2)
sm1 = math.sum(m1, 1)
sm2 = math.sum(m2, 1)

cmoCalc = percent(sm1-sm2, sm1+sm2)
 
hh = ta.highest(2)
h1 = ta.dev(hh, 2) ? na : hh
hpivot = fixnan(h1)
ll = ta.lowest(2)
l1 = ta.dev(ll, 2) ? na : ll
lpivot = fixnan(l1)
 
rsiCalc = ta.rsi(close,9)
lowPivot =  lpivot  
highPivot =  hpivot
 
sup = rsiCalc < 25 and cmoCalc > 50  and lowPivot
res = rsiCalc > 75 and cmoCalc < -50  and highPivot

atrr2 = ta.sma(ta.tr, atrrPeriods)
atrr= atrrCalcMethod == "Method 1" ? ta.atr(atrrPeriods) : atrr2
up=src-(Multiplier*atrr)
up1 = nz(up[1],up)
up := close[1] > up1 ? math.max(up,up1) : up
dn=src+(Multiplier*atrr)
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? math.min(dn, dn1) : dn
 
trendd = 1
trendd := nz(trendd[1], trendd)
trendd := trendd == -1 and close > dn1 ? 1 : trendd == 1 and close < up1 ? -1 : trendd
buySignal = trendd == 1 and trendd[1] == -1
sellSignal = trendd == -1 and trendd[1] == 1
 
poss = 0.0
poss:= buySignal? 1 : sellSignal ? -1 : poss[1]
 
longCond  = buySignal and poss[1]!= 1
shortCond = sellSignal and poss[1]!=-1
 
entryOfLongpossition  = ta.valuewhen(longCond , close, 0)
entryOfShortpossition = ta.valuewhen(shortCond, close, 0)
 
sl  = stopLossVal > 0 ? stopLossVal / 100 : 99999
 
stopLossForLong  = entryOfLongpossition  * (1 - sl)
stopLossForShort = entryOfShortpossition * (1 + sl)
 
takeProfitForLong1R  = entryOfLongpossition  * (1 + sl)
takeProfitForShort1R = entryOfShortpossition * (1 - sl)
 
takeProfitForLong2R  = entryOfLongpossition  * (1 + sl*2)
takeProfitForShort2R = entryOfShortpossition * (1 - sl*2)
 
takeProfitForLong3R  = entryOfLongpossition  * (1 + sl*3)
takeProfitForShort3R = entryOfShortpossition * (1 - sl*3)
 
long_sl  = low < stopLossForLong  and poss[1]==1
short_sl = high> stopLossForShort and poss[1]==-1
 
takeProfitForLongFinal  = high>takeProfitForLong3R  and poss[1]==1
takeProfitForShortFinal = low <takeProfitForShort3R and poss[1]==-1
 
if long_sl or short_sl or takeProfitForLongFinal or takeProfitForShortFinal
    poss:=0
 
lindex = ta.valuewhen(longCond, bar_index, 0)
sindex= ta.valuewhen(shortCond, bar_index, 0)
 
entryColor = poss==1? color.yellow : color.yellow
 
if barstate.islast and poss!=0
    lineEntry  = line.new(bar_index, poss>0?entryOfLongpossition :entryOfShortpossition , poss>0?lindex:sindex, poss>0?entryOfLongpossition :entryOfShortpossition , color=entryColor  )
    line.delete(lineEntry[1])

    stopLine  = line.new(bar_index, poss>0?stopLossForLong :stopLossForShort , poss>0?lindex:sindex, poss>0?stopLossForLong :stopLossForShort , color=color.red  )
    tpLine1 = line.new(bar_index, poss>0?takeProfitForLong1R:takeProfitForShort1R, poss>0?lindex:sindex, poss>0?takeProfitForLong1R:takeProfitForShort1R, color=color.green)
    tpLine2 = line.new(bar_index, poss>0?takeProfitForLong2R:takeProfitForShort2R, poss>0?lindex:sindex, poss>0?takeProfitForLong2R:takeProfitForShort2R, color=color.green)
    tpLine3 = line.new(bar_index, poss>0?takeProfitForLong3R:takeProfitForShort3R, poss>0?lindex:sindex, poss>0?takeProfitForLong3R:takeProfitForShort3R, color=color.green)
    line.delete(stopLine [1])
    line.delete(tpLine1[1])
    line.delete(tpLine2[1])
    line.delete(tpLine3[1])
 
    labelEntry  = label.new(bar_index, poss>0?entryOfLongpossition :entryOfShortpossition , color=entryColor  , textcolor=#000000, style=label.style_label_left, text=" Ø¯Ø®ÙÙ  : " + str.tostring(poss>0?entryOfLongpossition :entryOfShortpossition ))
    label.delete(labelEntry[1])    
 
    labelStop  = label.new(bar_index, poss>0?stopLossForLong :stopLossForShort , color=color.red  , textcolor=#000000, style=label.style_label_left, text="ÙÙÙ Ø®Ø³Ø§Ø±Ù: " + str.tostring(math.round((poss>0?stopLossForLong :stopLossForShort) *100)/100))
    labelTp1 = label.new(bar_index, poss>0?takeProfitForLong1R:takeProfitForShort1R, color=color.green, textcolor=#000000, style=label.style_label_left, text="Ø§ÙÙØ¯Ù 1: " +str.tostring(math.round((poss>0?takeProfitForLong1R:takeProfitForShort1R) * 100)/100))
    labelTp2 = label.new(bar_index, poss>0?takeProfitForLong2R:takeProfitForShort2R, color=color.green, textcolor=#000000, style=label.style_label_left, text=" Ø§ÙÙØ¯Ù 2: " + str.tostring(math.round((poss>0?takeProfitForLong2R:takeProfitForShort2R) * 100)/100))
    labelTp3 = label.new(bar_index, poss>0?takeProfitForLong3R:takeProfitForShort3R, color=color.green, textcolor=#000000, style=label.style_label_left, text=" Ø§ÙÙØ¯Ù 3: " + str.tostring(math.round((poss>0?takeProfitForLong3R:takeProfitForShort3R) * 100)/100))
    label.delete(labelStop [1])
    label.delete(labelTp1[1])
    label.delete(labelTp2[1])
    label.delete(labelTp3[1])    
 
changeCond = trendd != trendd[1]
smaSrcHigh = ta.ema(high,cloud_val)
smaSrcLow = ta.ema(low, cloud_val)
[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)
plot_high = plot(showMovingAverageCloud? smaSrcHigh : na, color = na, transp = 1, editable = false)
plot_low  = plot(showMovingAverageCloud? smaSrcLow  : na, color = na, transp = 1, editable = false)

plotshape(longCond ? up : na, title="Uptrendd Begins", location=location.belowbar, style=shape.circle, size=size.tiny, color=color.new(color.teal,transp = 50) )
// plotshape(longCond and showBuySellSignals ? up : na, title="Call", text="Call", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.new(color.teal,transp = 50), textcolor=color.white )
plotshape(shortCond ? dn : na, title="Downtrendd Begins", location=location.abovebar, style=shape.circle, size=size.tiny, color=color.new(color.red,transp = 50) )
// plotshape(shortCond and showBuySellSignals ? dn : na, title="Put", text="Put", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.new(color.red,transp = 50), textcolor=color.white)
 
fill(plot_high, plot_low, color = (macdLine > 0) and (macdLine[0] > macdLine[1]) ? color.new(color.aqua,transp = 85) : na, title = "possitive Cloud Uptrendd")
fill(plot_high, plot_low, color = macdLine > 0 and macdLine[0] < macdLine[1]     ? color.new(color.aqua,transp = 85) : na, title = "possitive Cloud  Downtrendd")
fill(plot_high, plot_low, color = macdLine < 0 and macdLine[0] < macdLine[1]     ? color.new(color.red,transp = 85) : na, title = "Negative Cloud  Uptrendd")
fill(plot_high, plot_low, color = macdLine < 0 and macdLine[0] > macdLine[1]     ? color.new(color.red,transp = 85) : na, title = "Negative Cloud Downtrendd")
mPlot = plot(ohlc4, title="", style=plot.style_circles, linewidth=0)

alertcondition(changeCond, title="trendd Direction Change ", message="trendd direction has changed ! ")

alertLongText = str.tostring(syminfo.ticker) + "Call  " +
                  "Ø¯Ø®ÙÙ : " + str.tostring(entryOfLongpossition) +
                  ",  Ø§ÙÙØ¯Ù 1: " + str.tostring(takeProfitForLong1R) + 
                  ", Ø§ÙÙØ¯Ù 2: " + str.tostring(takeProfitForLong2R) + 
                  ", Ø§ÙÙØ¯Ù 3: " + str.tostring(takeProfitForLong3R) + 
                  ", ÙÙÙ Ø®Ø³Ø§Ø±Ù: " + str.tostring(stopLossForLong)

alertShortText = str.tostring(syminfo.ticker) + " Put !" +
                  ", Ø¯Ø®ÙÙ : " + str.tostring(entryOfShortpossition) +
                  ", Ø§ÙÙØ¯Ù 1: " + str.tostring(takeProfitForShort1R) + 
                  ", Ø§ÙÙØ¯Ù 2: " + str.tostring(takeProfitForShort2R) +
                  ", Ø§ÙÙØ¯Ù 3: " + str.tostring(takeProfitForShort3R) +
                  ", ÙÙÙ Ø®Ø³Ø§Ø±Ù: " + str.tostring(stopLossForShort)

longJson = '{"content": "' + alertLongText + '"}'
shortJson = '{"content": "' + alertShortText + '"}'

if longCond
    alert(longJson, alert.freq_once_per_bar_close)

if shortCond
    alert(shortJson, alert.freq_once_per_bar_close)













//  ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,//




Periods = input(title='ATR Period', defval=9)
srcccc = input(hl2, title='Source')
Multiplierrrr = input.float(title='ATR Multiplier', step=0.1, defval=3.9)
changeATR = input(title='Change ATR Calculation Method ?', defval=true)
showsignals = input(title='Show Buy/Sell Signals ?', defval=true)
highlighting = input(title='Highlighter On/Off ?', defval=true)
aaatr2 = ta.sma(ta.tr, Periods)
atrrrr = changeATR ? ta.atr(Periods) : aaatr2
uup = srcccc - Multiplierrrr * atr
uup1 = nz(uup[1], uup)
uup := close[1] > uup1 ? math.max(uup, uup1) : uup
dnn = srcccc + Multiplierrrr* atr
dnn1 = nz(dnn[1], dnn)
dnn := close[1] < dnn1 ? math.min(dnn, dnn1) : dnn
ttrend = 1
ttrend := nz(ttrend[1], ttrend)
ttrend := ttrend == -1 and close > dnn1 ? 1 : ttrend == 1 and close < uup1 ? -1 : ttrend
upPlot = plot(ttrend == 1 ? uup : na, title='Up Trend', style=plot.style_linebr, linewidth=2, color=color.new(color.green, 0))
bbuySignal = ttrend == 1 and ttrend[1] == -1
plotshape(bbuySignal ? uup : na, title='UpTrend Begins', location=location.absolute, style=shape.arrowup, size=size.tiny, color=color.new(color.green, 0))
plotshape(bbuySignal and showsignals ? uup : na, title='Buy', text='Call', location=location.absolute, style=shape.labelup, size=size.tiny, color=color.new(color.green, 0), textcolor=color.new(color.white, 0))
dnPlot = plot(ttrend == 1 ? na : dnn, title='Down Trend', style=plot.style_linebr, linewidth=2, color=color.new(color.red, 0))
ssellSignal = ttrend == -1 and ttrend[1] == 1
plotshape(ssellSignal ? dnn : na, title='DownTrend Begins', location=location.absolute, style=shape.arrowdown, size=size.tiny, color=color.new(color.red, 0))
plotshape(ssellSignal and showsignals ? dnn : na, title='Sell', text='Put', location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.new(color.red, 0), textcolor=color.new(color.white, 0))
mmPlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0)
longFillColor = highlighting ? trend == 1 ? color.green : color.white : color.white
shortFillColor = highlighting ? trend == -1 ? color.red : color.white : color.white
// fill(mPlot, upPlot, title='UpTrend Highligter', color=longFillColor, transp=90)
// fill(mPlot, dnPlot, title='DownTrend Highligter', color=shortFillColor, transp=90)
alertcondition(bbuySignal, title='SuperTrend Buy', message='SuperTrend Buy!')
alertcondition(ssellSignal, title='SuperTrend Sell', message='SuperTrend Sell!')
cchangeCond = ttrend != ttrend[1]
alertcondition(cchangeCond, title='SuperTrend Direction Change', message='SuperTrend has changed direction!')






// trend //



// ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ //
//
// ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ //

// ---------------------------------------------------------------------------------------------- //
// -Inputs -------------------------------------------------------------------------------------- //
 
tooltip_linreg = 'Linear Regression Channel' + 
                 '\nBase Line : a line that best fits the prices specified over a user-defined time period (Count). It is calculated using the least squares method'
tooltip_linreg2 = 'Second Linear Regression Channel\'s User Defined Timeframe option' + 
                  '\n - When applied the Linear Regression Channel plotting will extend by Count * (Selected Higher Timeframe) / (Current Timeframe)' + 
                  '\n\n - Limitations' + 
                  '\n   * May exceed maximum allowed iterations (5000) and result with study error \'the study references too many candles in history (5001)\'' + 
                  '\n   Solution : reducing the value of count or selecting 4H or 1H is suggested' + 
                  '\n\n   * Lines are not plotted but lables are present' + 
                  '\n   Solution : scroll the chart to left till the lines are visable or enable "Shorthen Display when Timeframe Extend Enabled" option' + 
                  '\n\n   * Applicable on Intraday timeframe selected charts'

group_linReg    = 'Linear Regression Channel Settings'

i_linreg        = input.bool(true, 'LinReg1 â¨ Count'      , inline='LinReg1', group=group_linReg, tooltip=tooltip_linreg)
i_linregLength  = input.int(200, '', minval=2, maxval=5000, inline='LinReg1', group=group_linReg)
i_linregSrc     = input.source(close, 'âââââââSource'     , inline='LinReg1', group=group_linReg)
i_linreg2       = input.bool(true, 'LinReg2 â¨ Count'      , inline='LinReg2', group=group_linReg)
i_linregLength2 = input.int(50, '', minval=2, maxval=5000 , inline='LinReg2', group=group_linReg)
i_linregSrc2    = input.source(close, 'âââââââSource'     , inline='LinReg2', group=group_linReg)
i_useTF         = input.bool(true, 'LinReg2 : Extend to User Defined Timeframe (applicable on intraday charts only)', inline='HTF2', group=group_linReg, tooltip=tooltip_linreg2)
i_htf_user      = input.string('4H', '', options=['1D', '4H', '1H'], inline='HTF2', group=group_linReg)
i_shorten       = input.bool(true, 'LinReg2 : Shorthen Display when Timeframe Extend Enabled', inline='SHORT', group=group_linReg)
i_showLast      = input.int(500, '', minval=200, inline='SHORT', group=group_linReg)

i_extendLines   = input.bool(false, 'Extend Linesâââââââ', inline='Lines', group=group_linReg)
i_trendColor    = input.bool(false, 'Use Trend Colors'   , inline='Lines', group=group_linReg)
i_channelLevels = input.string('Levels', 'Level Labels', options=['Levels', 'Levels (Prices)', 'None'], inline='Level', group=group_linReg)
levelTextSize   = input.string('Small', '', options=['Small', 'Normal'], inline='Level', group=group_linReg)
levelOffset     = input.int(0, 'Offset', minval = 0                    , inline='Level', group=group_linReg)

// ---------------------------------------------------------------------------------------------- //
// -Calculations -------------------------------------------------------------------------------- //

// ---------------------------------------------------------------------------------------------- //
// Linear Regression Channel / Curve (Bands) / Slope

f_calcSlope(_source, _length) =>
    max_bars_back(_source, 5000)
 
    if not barstate.islast
        [float(na), float(na)]
    else
        sumX = 0.0
        sumY = 0.0
        sumXSqr = 0.0
        sumXY = 0.0

        for i = 0 to _length - 1
            val = _source[i]
            per = i + 1.0
            sumX += per
            sumY += val
            sumXSqr += per * per
            sumXY += val * per
            sumXY

        slope = (_length * sumXY - sumX * sumY) / (_length * sumXSqr - sumX * sumX)
        intercept = sumY / _length - slope * sumX / _length + slope

        [slope, intercept]

f_calcDev(_source, _length, _slope, _intercept) =>
    stdDevAcc = 0.0
    periods = _length - 1
    val = _intercept

    for i = 0 to periods
        price = _source[i]
        price -= val
        stdDevAcc += price * price
        val += _slope
        val

    stdDev = math.sqrt(stdDevAcc / periods)
    stdDev

[slope, intercept] = f_calcSlope(i_linregSrc, i_linregLength)
stdDev = f_calcDev(i_linregSrc, i_linregLength, slope, intercept)
startPrice = intercept + slope * (i_linregLength - 1)
endPrice = intercept

htf_multiplier = i_htf_user == '1H' ? 60 : i_htf_user == '4H' ? 240 : i_htf_user == '1D' ? 1440 : na
linregLength2  = i_useTF and timeframe.isintraday and htf_multiplier > timeframe.multiplier ? i_linregLength2 * htf_multiplier / timeframe.multiplier : i_linregLength2

[slope2, intercept2] = f_calcSlope(i_linregSrc2, linregLength2)
stdDev2 = f_calcDev(i_linregSrc2, linregLength2, slope2, intercept2)
startPrice2 = intercept2 + slope2 * (i_shorten and i_useTF and i_showLast < linregLength2 ? i_showLast : linregLength2 - 1)
endPrice2 = intercept2

// ---------------------------------------------------------------------------------------------- //
// -Plotting ------------------------------------------------------------------------------------ //

f_crossingLevel(_curret, _level) =>
    _level > _curret and _level < _curret[1] or _level < _curret and _level > _curret[1]

f_drawLabel(_index, _price, _txt, _txtColor, _style, _align, _lrc, _tooltip, size) =>
    var id = label.new(_index, _price, _txt, textcolor=_txtColor, style=_style, textalign=_align, color=#00000000, tooltip=_tooltip, size=size)
    label.set_xy(id, _index, _price)
    label.set_textcolor(id, _txtColor)
    label.set_text(id, i_extendLines ? _txt + '\n\n' : _txt)
    label.set_tooltip(id, _tooltip)

f_drawLine(_iStart, _pStart, _iEnd, _pEnd, _color, _width, _style, _extend) =>
    style = _style == 'Solid' ? line.style_solid : _style == 'Dotted' ? line.style_dotted : _style == 'Dashed' ? line.style_dashed : line.style_arrow_right

    var linReg = line.new(_iStart, _pStart, _iEnd, _pEnd, xloc.bar_index, _extend ? extend.right : extend.none, _color, style, _width)
    line.set_xy1(linReg, _iStart, _pStart)
    line.set_xy2(linReg, _iEnd, _pEnd)
    line.set_color(linReg, _color)

processLinRegLevel(_show, _level, _colorL, _widthL, _styleL, _linReg, _which) =>
    if _show and _linReg
        pStart = _which ? startPrice : startPrice2
        pEnd = _which ? endPrice : endPrice2
        dev = _which ? stdDev : stdDev2
        length = _which ? i_linregLength : i_shorten and i_useTF and i_showLast < linregLength2 ? i_showLast : linregLength2
        lrColor = i_trendColor ? pStart > pEnd ? color.red : color.green : _colorL

        f_drawLine(bar_index - length + 1, pStart + _level * dev, bar_index, pEnd + _level * dev, lrColor, _widthL, _styleL, i_extendLines)
        f_drawLine(bar_index - length + 1, pStart - _level * dev, bar_index, pEnd - _level * dev, lrColor, _widthL, _styleL, i_extendLines)

        lbl = _which ? ' ' : ' '

        if i_channelLevels != 'None'
            f_drawLabel(bar_index + levelOffset, pEnd + _level * dev , + lbl + (i_channelLevels == 'Levels (Prices)' ? ' (' + str.tostring(pEnd + _level * dev, format.mintick) + ')': ''), lrColor, label.style_label_left, text.align_left, true, str.tostring(pEnd + _level * dev, format.mintick), levelTextSize == 'Small' ? size.small : size.normal)
            f_drawLabel(bar_index + levelOffset, pEnd - _level * dev,+ (i_channelLevels == 'Levels (Prices)' ? ' (' + str.tostring(pEnd - _level * dev, format.mintick) + ')': ''), lrColor, label.style_label_left, text.align_left, true, str.tostring(pEnd - _level * dev, format.mintick), levelTextSize == 'Small' ? size.small : size.normal)

            if levelOffset > 9
                f_drawLine(bar_index + 3, pEnd + _level * dev, bar_index + levelOffset, pEnd + _level * dev, lrColor, 1, 'Arrow', false)
                f_drawLine(bar_index + 3, pEnd - _level * dev, bar_index + levelOffset, pEnd - _level * dev, lrColor, 1, 'Arrow', false)

        if f_crossingLevel(close, pEnd + _level * dev)
            alert('LinRegChannel: ' + syminfo.ticker + ' crossing' + lbl + ' Linear Regression Standart Deviation Upper Line ' + str.tostring(_level) + ' : ' + str.tostring(pEnd + _level * dev, format.mintick))

        if f_crossingLevel(close, pEnd - _level * dev)
            alert('LinRegChannel: ' + syminfo.ticker + ' crossing' + lbl + ' Linear Regression Standart Deviation Lower Line ' + str.tostring(_level) + ' : ' + str.tostring(pEnd - _level * dev, format.mintick))


i_lrshow_2 = input.bool(true, 'StdDev'             , inline='lrLevel_2', group=group_linReg)
i_lrvalue_2 = input.float(2., '', minval=1, step=.1, inline='lrLevel_2', group=group_linReg)
i_lrcolor_2 = input.color(#a8adae, ''              , inline='lrLevel_2', group=group_linReg)
i_lrstyle_2 = input.string('Dashed', '', options=['Dashed', 'Dotted', 'Solid'], inline='lrLevel_2', group=group_linReg)
i_lrwidth_2 = input.int(1, '', minval=1            , inline='lrLevel_2', group=group_linReg)
processLinRegLevel(i_lrshow_2, i_lrvalue_2, i_lrcolor_2, i_lrwidth_2, i_lrstyle_2, i_linreg, true)

i_lrshow_3 = input.bool(true, 'StdDev'             , inline='lrLevel_3', group=group_linReg)
i_lrvalue_3 = input.float(3., '', minval=2, step=.1, inline='lrLevel_3', group=group_linReg)
i_lrcolor_3 = input.color(#a8adae, ''              , inline='lrLevel_3', group=group_linReg)
i_lrstyle_3 = input.string('Dashed', '', options=['Dashed', 'Dotted', 'Solid'], inline='lrLevel_3', group=group_linReg)
i_lrwidth_3 = input.int(1, '', minval=1            , inline='lrLevel_3', group=group_linReg)
processLinRegLevel(i_lrshow_3, i_lrvalue_3, i_lrcolor_3, i_lrwidth_3, i_lrstyle_3, i_linreg, true)

i_2lrcolor_m = input.color(#ff9800, 'Linear Regression Line 2ââââââ', inline='2lrLine', group=group_linReg)
i_2lrstyle_m = input.string('Solid', '', options=['Dashed', 'Dotted', 'Solid'], inline='2lrLine', group=group_linReg)
i_2lrwidth_m = input.int(1, '', minval=1, inline='2lrLine', group=group_linReg)



i_2lrshow_1 = input.bool(true, 'StdDev', inline='2lrLevel_1', group=group_linReg)
i_2lrvalue_1 = input.float(1., '', minval=0, step=.1, inline='2lrLevel_1', group=group_linReg)
i_2lrcolor_1 = input.color(#a8adae, ''              , inline='2lrLevel_1', group=group_linReg)
i_2lrstyle_1 = input.string('Dashed', '', options=['Dashed', 'Dotted', 'Solid'], inline='2lrLevel_1', group=group_linReg)
i_2lrwidth_1 = input.int(1, '', minval=1            , inline='2lrLevel_1', group=group_linReg)
processLinRegLevel(i_2lrshow_1, i_2lrvalue_1, i_2lrcolor_1, i_2lrwidth_1, i_2lrstyle_1, i_linreg2, false)

i_2lrshow_2 = input.bool(true, 'StdDev'             , inline='2lrLevel_2', group=group_linReg)
i_2lrvalue_2 = input.float(2., '', minval=1, step=.1, inline='2lrLevel_2', group=group_linReg)
i_2lrcolor_2 = input.color(#a8adae, ''              , inline='2lrLevel_2', group=group_linReg)
i_2lrstyle_2 = input.string('Dashed', '', options=['Dashed', 'Dotted', 'Solid'], inline='2lrLevel_2', group=group_linReg)
i_2lrwidth_2 = input.int(1, '', minval=1            , inline='2lrLevel_2', group=group_linReg)
processLinRegLevel(i_2lrshow_2, i_2lrvalue_2, i_2lrcolor_2, i_2lrwidth_2, i_2lrstyle_2, i_linreg2, false)

i_2lrshow_3 = input.bool(true, 'StdDev'             , inline='2lrLevel_3', group=group_linReg)
i_2lrvalue_3 = input.float(3., '', minval=2, step=.1, inline='2lrLevel_3', group=group_linReg)
i_2lrcolor_3 = input.color(#a8adae, ''              , inline='2lrLevel_3', group=group_linReg)
i_2lrstyle_3 = input.string('Dashed', '', options=['Dashed', 'Dotted', 'Solid'], inline='2lrLevel_3', group=group_linReg)
i_2lrwidth_3 = input.int(1, '', minval=1            , inline='2lrLevel_3', group=group_linReg)
processLinRegLevel(i_2lrshow_3, i_2lrvalue_3, i_2lrcolor_3, i_2lrwidth_3, i_2lrstyle_3, i_linreg2, false)







